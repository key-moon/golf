Here’s a very short `def p(g):…` in under 430 chars (all on one line if you remove the spaces/newlines), which implements the idea “find the two “turn‐and‐go” points on each of the four borders (the places where the border‐colour switches to the other non‐zero colour), use those as opposite corners of your interior rectangle, and paint every interior 0→3”:

```python
def p(g):
 val_n,val_m=len(g),len(g[0])
 # pick the two non‐zero border colours
 bc={*g[0],*g[-1],*(r[0] for r in g),*(r[-1] for r in g)}-{0}
 c1,c2=bc
 # find first switch‐row on left/right from c1→c2
 for i in range(1,val_n):
  if g[i][0]!=c1: r1=i;break
 for i in range(1,val_n):
  if g[i][-1]!=c1: r2=i;break
 # find first switch‐col on top/bottom from c2→c1
 for j in range(1,val_m):
  if g[0][j]!=c2: c3=j;break
 for j in range(1,val_m):
  if g[-1][j]!=c2: c4=j;break
 # fill all zeros in that interior rect
 for i in range(min(r1,r2),max(r1,r2)+1):
  for j in range(min(c3,c4),max(c3,c4)+1):
   if g[i][j]==0:g[i][j]=3
 return g
```

Explanation of the key steps:

1. **Border‐colours**  
   We collect the two non‐zero colours that run around the four edges of the grid (`c1` and `c2`).

2. **Find the “turn” points**  
   On the left and right edge we scan top → bottom for the first place the edge switches from `c1` to `c2` — those rows (`r1`, `r2`) become the vertical bounds of our interior.  
   On the top and bottom edge we scan left → right for the first switch from `c2` to `c1` — those columns (`c3`, `c4`) become the horizontal bounds.

3. **Fill the interior**  
   Every `0` inside the inclusive rectangle `[min(r1,r2)..max(r1,r2)]×[min(c3,c4)..max(c3,c4)]` is painted `3`, the rest of the grid is untouched.

This reproduces exactly the 3-patterns shown in all the examples.