Here’s a very short “golfed” solution.  We detect the separator‐colour on row 5, collect the “pattern” cells (anything non‐zero ≠sep) as offsets mod 6, then stamp that pattern into every 5×5 block, painting it with the separator colour whenever the target cell is 0:

```python
def p(g):
 val_s=g[5][0]
 val_r=[(i%6,j%6)for i,row in enumerate(g)for j,v in enumerate(row)if v and v!=val_s]
 for val_i in(0,6,12):
  for val_j in(0,6,12):
   for a,b in val_r:
    if g[val_i+a][val_j+b]==0: g[val_i+a][val_j+b]=val_s
 return g
```

Explanation of the key steps:

 1.  val_s = g[5][0]  
    – the “separator” colour (every 6th row/column has it).

 2.  val_r = [ (i%6,j%6) … ]  
    – all non‐zero cells ≠ separator are the prototype shape, recorded as offsets within their 6×6 tile.

 3.  for each tile origin (val_i,val_j) in {0,6,12}², for each offset (a,b) in val_r:  
    if that cell is still 0, paint it with the separator colour.

This reproduces the sample transformations exactly.