```python
def p(g):
    R,C=len(g),len(g[0])
    # find zero‐components that don't touch the border (the “holes”)
    holes=[]; seen0=set()
    for i in range(R):
        for j in range(C):
            if g[i][j]==0 and (i,j) not in seen0:
                stack=[(i,j)]; comp=[]; ok=True
                while stack:
                    x,y=stack.pop()
                    if (x,y) in seen0 or not (0<=x<R and 0<=y<C) or g[x][y]!=0: continue
                    seen0.add((x,y)); comp.append((x,y))
                    if x in (0,R-1) or y in (0,C-1): ok=False
                    for dx,dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        stack.append((x+dx,y+dy))
                if ok: holes.append(comp)
    # find the two colored shapes (non‐zero, non‐5)
    shapes=[]; seenS=set()
    for i in range(R):
        for j in range(C):
            v=g[i][j]
            if v not in (0,5) and (i,j) not in seenS:
                stack=[(i,j)]; comp=[]; col=v
                while stack:
                    x,y=stack.pop()
                    if (x,y) in seenS or not (0<=x<R and 0<=y<C) or g[x][y]!=col: continue
                    seenS.add((x,y)); comp.append((x,y))
                    for dx,dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        stack.append((x+dx,y+dy))
                shapes.append((col,comp))
    # normalize comps to relative sets
    def norm(comp):
        mi=min(x for x,y in comp); mj=min(y for x,y in comp)
        return set((x-mi,y-mj) for x,y in comp),(mi,mj)
    hole_norms=[]; hole_orig=[]
    for c in holes:
        n,base=norm(c); hole_norms.append(n); hole_orig.append(base)
    shape_cols=[]; shape_norms=[]; shape_orig=[]
    for col,comp in shapes:
        n,base=norm(comp)
        shape_norms.append(n); shape_orig.append(base); shape_cols.append(col)
    # assign each shape to the hole it originally filled
    sh2hole=[None]*len(shapes)
    for si,sn in enumerate(shape_norms):
        for hi,hn in enumerate(hole_norms):
            if sn==hn:
                sh2hole[si]=hi
                break
    # clear old shapes
    for _,comp in shapes:
        for x,y in comp: g[x][y]=0
    # place each shape into the other hole
    for si,(col,comp) in enumerate(shapes):
        dest_hole=1-sh2hole[si]
        base=hole_orig[dest_hole]
        for dx,dy in shape_norms[si]:
            g[base[0]+dx][base[1]+dy]=col
    return g
```