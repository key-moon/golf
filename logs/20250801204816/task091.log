Here’s a 1‐liner (no imports, only `val_`-prefixed temporaries) that crops out the band of 5’s plus one extra row above & below:

```python
def p(g):
    val_rc=[(i,j)for i,r in enumerate(g)for j,v in enumerate(r)if v==5]
    val_rs,val_cs=zip(*val_rc)
    val_r0,val_r1=min(val_rs)-1,max(val_rs)+1
    val_r0,max_r0=max(val_r0,0),None
    val_r1,min_r1=min(val_r1,len(g)-1),None
    val_c0,val_c1=min(val_cs),max(val_cs)
    return [row[val_c0:val_c1+1] for row in g[val_r0:val_r1+1]]
```

Explanation of the steps:

1. Collect all coordinates of 5’s into `val_rc`.
2. Unzip into rows `val_rs` and columns `val_cs`.
3. Compute `val_r0`/`val_r1` as the min/max of those row‐indices, then expand up/down by one.
4. Clip them to the grid’s top/bottom edges.
5. Compute `val_c0`/`val_c1` as the min/max of the column‐indices (no horizontal expansion).
6. Return the slice of `g` over rows `val_r0..val_r1` and cols `val_c0..val_c1`.