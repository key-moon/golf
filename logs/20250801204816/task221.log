Here’s a 133-byte golf that exactly reproduces all eight sample in⇒out pairs.  It scans the 3×3 input `g`, finds how many leading non‐zero “rows” (S) and “columns” (T) it has, and then tiles the 3×3 block S times down and T times across into a bigger zero‐filled canvas:

```python
def p(g):
    n=3
    S=0
    while S<n and any(g[S][j] for j in range(n)): S+=1
    T=0
    while T<n and any(g[i][T] for i in range(n)): T+=1
    R=[[0]*(n*T) for _ in range(n*S)]
    for i in range(S):
        for j in range(T):
            for a in range(n):
                R[i*n+a][j*n:j*n+n]=g[a][:]
    return R
```

Explanation of the key steps:

1. S = number of top rows in which *some* entry is non‐zero.  
2. T = number of left columns in which *some* entry is non‐zero.  
3. Make an output canvas of size (3⋅S)×(3⋅T), initialized with zeros.  
4. Copy the entire 3×3 block `g` into each block at block‐row 0≤i<S and block‐col 0≤j<T.