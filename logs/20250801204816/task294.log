Here’s a very short “golfy” Python solution.  It walks the grid looking for the top‐left corner of each solid 5–block, measures its width/height, and then replaces every strictly interior 5 with a 2.  All locals (except `_`) are prefixed with `val_` as requested:

```python
def p(g):
 val_m,val_n=len(g),len(g[0])
 for val_i in range(val_m):
  for val_j in range(val_n):
   if g[val_i][val_j]==5 and (val_i==0 or g[val_i-1][val_j]!=5) and (val_j==0 or g[val_i][val_j-1]!=5):
    val_h=1
    while val_i+val_h<val_m and g[val_i+val_h][val_j]==5: val_h+=1
    val_w=1
    while val_j+val_w<val_n and g[val_i][val_j+val_w]==5: val_w+=1
    for val_r in range(val_i+1, val_i+val_h-1):
     for val_c in range(val_j+1, val_j+val_w-1):
      if g[val_r][val_c]==5: g[val_r][val_c]=2
 return g
```

Explanation of the key steps:

1. Scan every cell `(val_i,val_j)`.  
2. Whenever you hit a 5 that has no 5 above it and no 5 to its left, that must be the top‐left corner of one of our solid 5–blocks.  
3. Walk downwards to find its full height (`val_h`) and rightwards to find its full width (`val_w`).  
4. Fill every interior cell (strictly inside that rectangle) that still reads 5 with a 2.  
5. Return the mutated grid.