Here’s a 95-byte golfed solution.  It takes an n×n grid val_g, makes a 2n×2n zero grid, and “slides” val_g diagonally all the way from (0,0) to (2n−1,2n−1):

```
def p(val_g):
    val_n=len(val_g)
    val_o=[[0]*(val_n*2)for _ in range(val_n*2)]
    for val_i in range(val_n):
      for val_j in range(val_n):
        for val_k in range(val_n*2-max(val_i,val_j)):
          val_o[val_i+val_k][val_j+val_k]=val_g[val_i][val_j]
    return val_o
```

Explanation of the core rule:

- You create an output canvas twice as big in each dimension.
- For every cell (i,j) in the input (even zeros!), you copy its value along the diagonal starting at (i,j) and ending at the bottom‐right corner of the big canvas.
- That “sliding” is done by letting k run from 0 up to the point where i+k or j+k would overrun, i.e. `k<2n−max(i,j)`.