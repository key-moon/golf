Here is a short self‐contained Python solution in golf style.  It finds each non-8 connected region, looks for exactly two “seed” colours (non‐zero, non‐8), and then fills that entire region with a checkerboard of those two colours so that the original seeds stay in place.

```python
def p(g):
 val_h=len(g);val_w=len(g[0]);val_v=set()
 for val_i in range(val_h):
  for val_j in range(val_w):
   if g[val_i][val_j]!=8 and (val_i,val_j) not in val_v:
    val_st=[(val_i,val_j)];val_comp=[];val_s={}
    val_v.add((val_i,val_j))
    while val_st:
     val_ci,val_cj=val_st.pop();val_comp.append((val_ci,val_cj))
     val_x=g[val_ci][val_cj]
     if val_x>0 and val_x not in val_s:val_s[val_x]=(val_ci,val_cj)
     for val_di,val_dj in((1,0),(-1,0),(0,1),(0,-1)):
      val_ni,val_nj=val_ci+val_di,val_cj+val_dj
      if 0<=val_ni<val_h and 0<=val_nj<val_w and g[val_ni][val_nj]!=8 and (val_ni,val_nj) not in val_v:
       val_v.add((val_ni,val_nj));val_st.append((val_ni,val_nj))
    if len(val_s)==2:
     val_a,val_b=sorted(val_s);val_ia,val_ja=val_s[val_a];val_p=(val_ia+val_ja)&1
     for val_ci,val_cj in val_comp:
      g[val_ci][val_cj]=val_a if ((val_ci+val_cj)&1)==val_p else val_b
 return g
```

Explanation outline:

1.  We treat “8” as an unfillable wall; everything else is open.
2.  We flood‐fill each open region, collecting its coordinates (`val_comp`) and any “seed” colours (cells >0 and ≠8) into `val_s`.
3.  If exactly two distinct seed colours appear, we pick them (small one as `a`, large one as `b`), take the first seed’s parity `(i+j)&1` to fix which parity belongs to `a`, and then fill the entire region in a checkerboard of `a`/`b`.
4.  Regions with zero or just one seed are left untouched.
5.  Finally we return the mutated grid `g`.