Here’s a single‐function “golfy” solution that implements the rule: for each full‐row or full‐column stripe of a non‐zero color, any off-stripe cell of that same color “casts” a new cell adjacent to the stripe on the same side as itself.  All variable names except `_` are prefixed with `val_` and there are no unnecessary imports or line breaks beyond the required `def` block:

```python
def p(val_g):
    val_h,val_w=len(val_g),len(val_g[0]);val_d={}
    for val_i in range(val_h):
        val_c=val_g[val_i][0]
        if val_c and val_g[val_i].count(val_c)==val_w:
            val_d.setdefault(val_c,[]).append((1,val_i))
    for val_j in range(val_w):
        val_c=val_g[0][val_j]
        if val_c and all(val_g[val_i][val_j]==val_c for val_i in range(val_h)):
            val_d.setdefault(val_c,[]).append((0,val_j))
    for val_x,val_row in enumerate(val_g):
        for val_y,val_v in enumerate(val_row):
            for val_t,val_k in val_d.get(val_v,()):
                if val_t and val_x!=val_k:
                    val_g[val_k+(1 if val_x>val_k else -1)][val_y]=val_v
                if not val_t and val_y!=val_k:
                    val_g[val_x][val_k+(1 if val_y>val_k else -1)]=val_v
    return val_g
```

Explanation of the key steps:
1. **Detect stripes**:  
   – A horizontal stripe is any row whose every entry equals a non-zero color `c`.  
   – A vertical stripe is any column whose every entry equals a non-zero color `c`.  
   We record each stripe in `val_d[c]` as `(1,row_index)` for horizontal or `(0,col_index)` for vertical.

2. **Cast new cells**:  
   For every cell `(x,y)` of color `v` that matches any stripe color and is not itself on that stripe, we “cast” a new cell immediately adjacent to the stripe on the same side as the original cell:
   – For a horizontal stripe at row `k`: if `x<k` we set `(k-1,y)=v`; if `x>k` we set `(k+1,y)=v`.  
   – For a vertical stripe at column `k`: if `y<k` we set `(x,k-1)=v`; if `y>k` we set `(x,k+1)=v`.  

This exactly recreates all the example transformations.