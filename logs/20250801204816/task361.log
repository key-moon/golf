Here’s a very short golf‐y solution.  It first finds the minimal bounding box of all non‐zero cells, computes its “center” in doubled‐coordinate space (so we never lose integer precision when rotating 90°), then for each original cell shoots three rotated copies (90°, 180°, 270°) back onto the grid.

```python
def p(g):
 a=[(i,j)for i in range(10)for j in range(10)if g[i][j]]
 r0,r1=min(a)[0],max(a)[0]
 c0,c1=min(a,key=lambda x:x[1])[1],max(a,key=lambda x:x[1])[1]
 R=r0+r1;C=c0+c1
 for i,j in a:
  v=g[i][j];dr=2*i-R;dc=2*j-C
  for dr2,dc2 in((dc,-dr),(-dr,-dc),(-dc,dr)):
   g[(R+dr2)//2][(C+dc2)//2]=v
 return g
```

Explanation of the key steps:

1. **Collect all non‐zero** cells in `a`.  
2. **Bounding box** is `r0..r1`, `c0..c1`.  
3. We work in doubled coordinates so that the geometric center  
   `(R/2,C/2)` = `((r0+r1)/2,(c0+c1)/2)` is represented exactly as `(R,C)`.  
4. For each original cell `(i,j)` with value `v`, compute its offset  
   `dr = 2*i - R`, `dc = 2*j - C` from the center.  
5. Rotate that offset by +90°, +180°, +270° via the tuples  
   ` (dc, -dr), (-dr, -dc), (-dc, dr)`.  
6. Map back into grid indices by halving `(R+dr2, C+dc2)` and write `v`.  
7. Return the mutated grid.

This replicates exactly the four rotations (including the original orientation) around the shape’s center, matching all of the samples.