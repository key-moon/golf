Here is a very short “code-golf” style solution.  It (1) finds the two columns that never change (the constant “borders”), (2) finds the first and last rows whose *interior* cells are all equal (the “top/bottom” boundaries), and (3) returns the sub‐grid between those rows and columns (inclusive).  All variables (except `_`) start with `val_`:

```python
def p(g):
 val_v=sorted(j for j in range(len(g[0]))if len({g[i][j]for i in range(len(g))})==1)
 val_a,val_b=val_v
 val_r=[i for i in range(len(g))if len({g[i][j]for j in range(val_a+1,val_b)})==1]
 return[row[val_a:val_b+1]for row in g[val_r[0]:val_r[-1]+1]]
```

Explanation of the key steps:

1. `val_v` collects all column-indices `j` where the set of values `{g[i][j]…}` down that column has size 1 (i.e. is constant).  
2. We sort and unpack as `(val_a,val_b)` to get the left and right borders.  
3. `val_r` collects all row-indices `i` whose interior cells (between `val_a` and `val_b`) all share the same value.  The first/last of these are the top and bottom boundaries.  
4. Finally we slice rows `val_r[0]..val_r[-1]` and columns `val_a..val_b` (inclusive).