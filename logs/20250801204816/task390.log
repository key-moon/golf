Here’s a fully self‐contained golfed solution.  It finds each 5‐component touching the 2‐border, removes it, detects the border line it touches, reflects that component across it, and writes the reflected 5s back.

```python
def p(val_g):
 val_O=[r[:]for r in val_g];h=len(val_g);w=len(val_g[0])
 S={(i,j)for i in range(h)for j in range(w)if val_g[i][j]==5}
 for i,j in S:val_g[i][j]=0
 while S:
  C={S.pop()};q=[*C]
  while q:
   i,j=q.pop()
   for di,dj in((1,0),(-1,0),(0,1),(0,-1)):
    x,y=i+di,j+dj
    if(x,y)in S:S.remove((x,y));C.add((x,y));q.append((x,y))
  B={(i+di,j+dj)for i,j in C for di,dj in((1,0),(-1,0),(0,1),(0,-1))
      if 0<=i+di<h and 0<=j+dj<w and val_O[i+di][j+dj]==2}
  rs={i for i,j in B};cs={j for i,j in B}
  if len(rs)==1:a,l=0,rs.pop()
  else:a,l=1,cs.pop()
  for i,j in C:
   if a:val_g[i][2*l-j]=5
   else:val_g[2*l-i][j]=5
 return val_g
```

Explanation (brief):

1. Copy the original grid into `val_O` for looking up the 2s even after we erase 5s.
2. Collect all 5‐cells into set `S` and clear them in `val_g`.
3. While any 5‐cell remains in `S`, flood‐fill one connected component `C` out of it.
4. Identify all border‐cells `B` of 2s adjacent to `C`, then group them by row (`rs`) or by column (`cs`).
5. Exactly one of these groups will have size 1 (the line of contact); that tells us whether to reflect across a horizontal line (`a=0`) or vertical line (`a=1`), and at which index `l`.
6. Reflect each cell of `C` across that line and paint a 5 in the new position.
7. Return the modified grid.