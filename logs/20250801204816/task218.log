Here’s a very short “block‐finder” solution.  It scans for the top‐left corner of each non‐zero rectangle, sorts them by row then column, groups by row, pads each row to the maximum width by repeating its last color, and returns the small grid of colors.

```python
def p(val_g):
    val_a=[];val_b=[];val_p=None
    for val_i,val_r in enumerate(val_g):
        for val_j,val_c in enumerate(val_r):
            # is top‐left of a nonzero block?
            if val_c and (val_i<1 or val_g[val_i-1][val_j]!=val_c) and (val_j<1 or val_r[val_j-1]!=val_c):
                val_a.append((val_i,val_j,val_c))
    val_a.sort()
    for val_y,_,val_c in val_a:
        if val_y!=val_p:
            val_b+=[[]]; val_p=val_y
        val_b[-1]+=[val_c]
    val_m = max(len(r) for r in val_b)
    for val_r in val_b:
        val_r += [val_r[-1]]*(val_m-len(val_r))
    return val_b
```

Explanation of the key steps:
1.  We walk every cell (val_i,val_j).  When we see a non‐zero val_c whose north and west neighbors are different (or out of bounds), that cell must be the top‐left corner of a uniformly‐colored rectangle.  
2.  We collect `(row,col,color)` triples, sort them, and then group by row.  
3.  Each row in `val_b` is then extended to the same length by repeating its last color.  
4.  The resulting 2D list is exactly the requested output.