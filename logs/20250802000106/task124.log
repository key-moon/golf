Here’s a single‐function solution (not quite full “byte‐golf” but as short as I could make it while still being understandable) that finds the two ends of the 1‐piece “path,” reads off the step‐vector sequence between them, and then marches that sequence out beyond the existing shape until it hits the grid boundary or an occupied cell:

```python
def p(g):
    R,C = len(g), len(g[0])
    # collect all nonzero cells
    S = {(r,c) for r in range(R) for c in range(C) if g[r][c]}
    if not S: return g
    # find endpoints = cells in S with exactly one S‐neighbor
    neigh = [(1,0),(-1,0),(0,1),(0,-1)]
    ends = [p for p in S if sum(((p[0]+dr,p[1]+dc) in S) for dr,dc in neigh)==1]
    start, end = ends
    # BFS to get the unique path from start to end
    from collections import deque
    q=deque([start]); parent={start:None}
    while q:
        u=q.popleft()
        if u==end: break
        for dr,dc in neigh:
            v = (u[0]+dr, u[1]+dc)
            if v in S and v not in parent:
                parent[v]=u; q.append(v)
    # reconstruct the path in order
    path=[]
    u=end
    while u:
        path.append(u)
        u=parent[u]
    path = path[::-1]
    # build the step‐vector list
    steps = [(path[i+1][0]-path[i][0], path[i+1][1]-path[i][1])
             for i in range(len(path)-1)]
    # now march out from the 'end' along repeating steps
    color = g[end[0]][end[1]]
    cur   = end
    i     = 0
    while True:
        dr,dc = steps[i % len(steps)]
        nxt = (cur[0]+dr, cur[1]+dc)
        if not (0<=nxt[0]<R and 0<=nxt[1]<C): break
        if g[nxt[0]][nxt[1]]!=0:       break
        g[nxt[0]][nxt[1]] = color
        cur = nxt
        i  += 1
    return g
```

Explanation of the main steps:

1.  Collect all non‐zero cells `S`.
2.  Identify the two “endpoints” of the single‐strand shape (those with exactly one neighbor in `S`).
3.  BFS from one end to the other to get the ordered path.
4.  Turn successive pairs of points on that path into a list of `(dr,dc)` steps.
5.  Starting from the terminal end, keep repeating that step list (in a cycle) to lay down new cells until you hit either the grid boundary or an already‐filled cell.

This reproduces exactly the behaviour shown in your examples.