Here’s a 1‐liner (no extra imports, in‐place recreation via return) that works for all the samples.  It simply computes the multiplication‐table mod m (where m is the max value seen) and fills every cell (zeros or not) by that rule—since all nonzero inputs already agree with i⋅j mod m+1:

```python
def p(g):val_m=max(max(val_r)for val_r in g);return[[val_i*val_j%val_m+1 for val_j,_ in enumerate(val_r)]for val_i,val_r in enumerate(g)]
```

Explanation:
- `val_m` ← the largest entry in the grid (so 5 in example 1, 6 in example 2, …).
- The new row _i_,col _j_ entry is `(i*j)%val_m+1`.  All the nonzero cells already matched that pattern, and the zeros get filled in correctly.