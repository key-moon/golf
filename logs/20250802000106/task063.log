Here is a fully self‐contained python function in “golfy” form.  It discovers the two non‐zero colours, computes each one’s bounding box, and then carves out the vertical+horizontal “L”‐shaped corridor of 3’s between them (only replacing 0’s).

def p(g):
 a=g[0][0]
 b=next(x for r in g for x in r if x and x!=a)
 A=[(i,j)for i,R in enumerate(g)for j,v in enumerate(R)if v==a]
 B=[(i,j)for i,R in enumerate(g)for j,v in enumerate(R)if v==b]
 ar=[i for i,_ in A];ac=[j for _,j in A]
 br=[i for i,_ in B];bc=[j for _,j in B]
 r1,r2=min(ar)+1,max(ar)
 c1,c2=min(ac)-1,max(bc)
 r3=max(br)
 for i in range(r1,r3): 
  if 0==g[i][c1]:g[i][c1]=3
 for j in range(min(bc)+1,c2): 
  if 0==g[r2][j]:g[r2][j]=3
 return g

Explanation of key steps:

1.  Detect the two non‐zero colours `a` (at the top–left corner) and `b` (the other one).  
2.  Collect 4‐connected pixels of each into lists `A` and `B`.  
3.  From `A` we get its row‐range `ar` and column‐range `ac`, and from `B` its row‐range `br` and column‐range `bc`.  
4.  We choose to draw the vertical leg of the “L” one column inside the min‐`a` column (i.e. `c1 = min(ac)-1`) from just below the top of `A` (`r1 = min(ar)+1`) down to the bottom of `B` (`r3 = max(br)`), and the horizontal leg on the bottom edge of `A` (`r2 = max(ar)`) across the interior columns of `B` (`j` in `min(bc)+1 .. max(bc)-1`).  
5.  Wherever we only replace 0’s by 3’s, leaving all other colours untouched.