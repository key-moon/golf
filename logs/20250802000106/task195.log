Here’s a terse golfed‐up Python solution.  It finds the 3×3 “block‐grid” in which 5’s occur, extracts those 3×3 blocs into a Boolean template, then tiles that template 3×3 times (filling with 5’s or 0’s) to produce a 9×9 output.

```
def p(g):
 val_d=3
 val_P=[(i//val_d,j//val_d)for i in range(len(g))for j in range(len(g[0]))if g[i][j]==5]
 val_r0=min(x for x,_ in val_P)*val_d;val_c0=min(y for _,y in val_P)*val_d
 val_S=[[sum(g[val_r0+val_d*i+ii][val_c0+val_d*j+jj]==5
             for ii in range(val_d)for jj in range(val_d))>0
         for j in range(3)]for i in range(3)]
 return[[5 if val_S[i//val_d][j//val_d]else 0
         for j in range(val_d*3)]for i in range(val_d*3)]
```

Explanation of the key steps:

 1. We scan the entire grid `g` in 3×3‐sized “blocks” (by integer‐dividing the row/col indices by 3) and collect those block‐indices where any cell is a 5.
 2. We find the top‐left of that 3×3 block‐region (`val_r0`, `val_c0`), extract a 3×3 Boolean template `val_S` that says which of those 3×3 meta‐cells contain 5’s.
 3. Finally we build a 9×9 result by tiling that 3×3 template 3×3 times, emitting 5’s where the template is True, else 0.