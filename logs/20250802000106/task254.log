Here’s a very golfy Python solution following the spec.  All locals except `_` are prefixed with `val_`, and there are no needless imports or comments:

```python
def p(g):
 val_n=len(g);val_m=len(g[0]);val_l=[0]*val_m
 for val_j in range(val_m):
  while val_l[val_j]<val_n and g[val_n-1-val_l[val_j]][val_j]==5:val_l[val_j]+=1
 val_x=[z for z in val_l if z];val_M=max(val_l);val_mn=min(val_x)
 val_jM=val_l.index(val_M);val_jm=val_l.index(val_mn)
 return [[1 if val_j==val_jM and val_i>=val_n-val_M
          else 2 if val_j==val_jm and val_i>=val_n-val_mn
          else 0
         for val_j in range(val_m)]
        for val_i in range(val_n)]
```

Explanation of the core steps:
1. For each column `j`, we count (`val_l[j]`) how many `5`‐cells run contiguously upward from the bottom.
2. We ignore zero‐length columns, take the max (longest suffix) and min (shortest non‐zero suffix).
3. We scan the grid row‐by‐row (index `i`) and column‐by‐column (`j`), emitting
   - `1` where `j` is the max‐suffix column and `i` is within that suffix,
   - `2` where `j` is the min‐suffix column and `i` is within that suffix,
   - `0` elsewhere.