Here is a single‐function solution in “golfed” form.  It first checks whether the stripes run horizontally or vertically (by inspecting row 0 for more than one non‐zero), transposes if needed, then walks the horizontal stripes, finds all zero‐columns in a stripe and fills them entirely, and finally re‐transposes when required.

```python
def p(val_g):
    val_t=0
    if len({x for x in val_g[0] if x})>1:
        val_g=[list(r) for r in zip(*val_g)]; val_t=1
    val_l,val_w=len(val_g),len(val_g[0]); val_i=0
    while val_i<val_l:
        val_c=next(x for x in val_g[val_i] if x); val_j=val_i
        while val_j<val_l and set(val_g[val_j])-{0}=={val_c}: val_j+=1
        val_z={k for r in range(val_i,val_j) for k in range(val_w) if val_g[r][k]==0}
        for r in range(val_i,val_j):
            for k in val_z: val_g[r][k]=0
        val_i=val_j
    if val_t:
        val_g=[list(r) for r in zip(*val_g)]
    return val_g
```

Explanation of the key steps:

1. **Orientation check**  
   If `row 0` contains more than one non‐zero value, we must have vertical stripes.  We transpose the grid so that we can treat everything as horizontal stripes.

2. **Stripe extraction**  
   We scan through the rows (`val_i` to `val_j`) looking for contiguous runs where all non‐zero entries are the same color (`val_c`).  Those runs ARE our stripes.

3. **Zero‐column fill**  
   Within each stripe, we gather all column indices `k` where any cell is zero, then set *every* cell in those columns (but only within the stripe rows) to zero.

4. **Final re‐transpose**  
   If we initially transposed, transpose back so that vertical stripes wound up modified correctly.

This correctly reproduces all of your provided examples.