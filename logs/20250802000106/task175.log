Below is a very short “golf‐style” Python solution.  It finds each 0‐cell, walks out along its NW–SE diagonal first “down‐right” (i+1,j+1), then “up‐left” (i−1,j−1), and as soon as it hits a non‐zero it copies that value back into the 0.  All variable names (except underscores) start with `val_` per your request:

```python
def p(val_g):
 for val_i in range(len(val_g)):
  for val_j in range(len(val_g[0])):
   if not val_g[val_i][val_j]:
    for val_k in range(1,len(val_g)):
     if val_i+val_k<len(val_g) and val_j+val_k<len(val_g[0]) and val_g[val_i+val_k][val_j+val_k]:
      val_g[val_i][val_j]=val_g[val_i+val_k][val_j+val_k];break
     if val_i>=val_k and val_j>=val_k and val_g[val_i-val_k][val_j-val_k]:
      val_g[val_i][val_j]=val_g[val_i-val_k][val_j-val_k];break
 return val_g
```

Explanation of the core idea:

1.  Loop over every cell `(val_i,val_j)`.  
2.  If the cell is zero, start stepping `val_k=1,2,…` along its SE diagonal (`(i+val_k,j+val_k)`) looking for the first non‐zero; if found, fill and stop.  
3.  Otherwise step along the NW diagonal (`(i−val_k,j−val_k)`) until you hit a non‐zero, fill and stop.  
4.  All zero‐cells get replaced by the nearest non‐zero on their NW–SE diagonal, which exactly restores the missing wedge in each of your examples.