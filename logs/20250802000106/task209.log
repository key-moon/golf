Here’s a one‐liner (avoiding unnecessary imports and line breaks) that crops out the minimal rectangle enclosing all 4’s:

```
def p(g):
    val_a=[(val_i,val_j)for val_i,val_row in enumerate(g)for val_j,val_v in enumerate(val_row)if val_v==4];val_r0=min(val_i for val_i,_ in val_a);val_r1=max(val_i for val_i,_ in val_a);val_c0=min(val_j for _,val_j in val_a);val_c1=max(val_j for _,val_j in val_a);return [val_row[val_c0:val_c1+1]for val_row in g[val_r0:val_r1+1]]
```

Explanation of the golfed parts:

- We scan the grid once to collect all `(row,col)` positions of the value `4` into `val_a`.
- We compute the minimal (`val_r0`,`val_c0`) and maximal (`val_r1`,`val_c1`) row/column indices of those 4’s.
- We then return the sub‐grid `g[val_r0..val_r1][val_c0..val_c1]`.