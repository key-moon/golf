Here’s a very short “golfed” Python solution (all on one “statement” after the `def`) that works for all the given examples.  It treats the grid as three equal‐height blocks, finds the row in block 0 with the longest run of 8’s, then “copies” those 8‐positions into the same relative row in blocks 1 and 2, marking 1’s wherever there isn’t already an 8:

```python
def p(g):
 val_h=len(g);val_w=len(g[0]);val_bs=val_h//3
 val_r=max(range(val_h),key=lambda y:sum(g[y][x]==8 for x in range(val_w)))
 val_cs=[x for x in range(val_w) if g[val_r][x]==8]
 for val_b in(1,2):
  for val_c in val_cs:
   i=val_r+val_b*val_bs
   if g[i][val_c]==0:g[i][val_c]=1
 return g
```

Explanation of the key steps:

1.  `val_bs=val_h//3`  
    We split the height into three equal blocks.

2.  `val_r=max(...,key=…)`  
    Find the row (`val_r`) in block 0 with the greatest count of 8’s.

3.  `val_cs=[…]`  
    Collect all column indices where that row has an 8.

4.  For each of the two lower blocks (`val_b=1,2`) we compute the target row  
    `i=val_r+val_b*val_bs` and set `g[i][x]=1` at each column `x` in `val_cs`, but only if it isn’t already an 8.