def YV(A,B):return type(B)(A(B)for B in B)
def P(A):return max(A for(A,B)in V(A))
def M(A):return max(A for(B,A)in V(A))
def GU(A):
	if isinstance(A,tuple):return frozenset({B for A in A for B in A})
	return frozenset({A for(A,B)in A})
def YE(A,B,C):return tuple(A[B[1]:B[1]+C[1]]for A in A[B[0]:B[0]+C[0]])
def YM(A,B):
	C,D=B;E,F=len(A),len(A[0])
	if not(0<=C<E and 0<=D<F):return
	return A[B[0]][B[1]]
def V(A):
	if len(A)==0:return frozenset()
	if isinstance(next(iter(A))[1],tuple):return frozenset(A for(B,A)in A)
	return A
def GM(A):return tuple(map(max,zip(*V(A))))
def GH(A):return tuple(map(min,zip(*V(A))))
def K(A):
	if len(A)==0:return A
	return YG(A,(-X(A),-GV(A)))
def G(A,B):
	C=set();L=K(B);D,E=len(A),len(A[0]);M,N=YY(B);O,P=D-M+1,E-N+1
	for F in range(O):
		for G in range(P):
			H=True
			for(Q,(I,J))in YG(L,(F,G)):
				if not(0<=I<D and 0<=J<E and A[I][J]==Q):H=False;break
			if H:C.add((F,G))
	return frozenset(C)
def Z(A):
	if len(A)==0:return frozenset({})
	B=V(A);C,D=GH(B);E,F=GM(A);return frozenset((A,B)for A in range(C,E+1)for B in range(D,F+1))
def HU(A):return X(A)+HX(A)//2,GV(A)+HL(A)//2
def GP(A,B):return YE(B,GH(A),YY(A))
def HQ(A,B):
	F,G=len(A),len(A[0]);C=list(list(A)for A in A)
	for(H,(D,E))in B:
		if 0<=D<F and 0<=E<G:C[D][E]=H
	return tuple(tuple(A)for A in C)
def HV(A):return tuple(tuple(A[::-1])for A in zip(*A[::-1]))[::-1]
def HE(A):return tuple(tuple(A[::-1])for A in A[::-1])
def YH(A):return tuple(A for A in zip(*A[::-1]))
def S(A):return frozenset((D,(A,C))for(A,B)in enumerate(A)for(C,D)in enumerate(B))
def E(a,b):return min(abs(A-C)+abs(B-D)for(A,B)in V(a)for(C,D)in V(b))
def GV(A):return min(A for(B,A)in V(A))
def X(A):return min(A for(A,B)in V(A))
def H(A):return frozenset(frozenset((A,(C,E))for(C,D)in enumerate(A)for(E,A)in enumerate(D)if A==B)for B in GU(A)-{Q(A)})
def YG(A,C):
	if len(A)==0:return A
	B,D=C
	if isinstance(next(iter(A))[1],tuple):return frozenset((A,(C+B,E+D))for(A,(C,E))in A)
	return frozenset((A+B,C+D)for(A,C)in A)
def Y(A,B):
	if isinstance(A,tuple):return sum(A.count(B)for A in A)
	return sum(A==B for(A,C)in A)
def YY(A):return HX(A),HL(A)
def HL(A):
	if len(A)==0:return 0
	if isinstance(A,tuple):return len(A[0])
	return M(A)-GV(A)+1
def HX(A):
	if len(A)==0:return 0
	if isinstance(A,tuple):return len(A)
	return P(A)-X(A)+1
def Q(A):B=[B for A in A for B in A]if isinstance(A,tuple)else[A for(A,B)in A];return max(set(B),key=B.count)
def GZ(A,B):return HP(YV(A,B))
def YR(A,a,b):return lambda x:A(a(x),b(x))
def HK(A,B):
	C=A.__code__.co_argcount
	if C==2:return lambda y:A(B,y)
	elif C==3:return lambda y,z:A(B,y,z)
	else:return lambda y,z,a:A(B,y,z,a)
def HZ(A,B):
	C=A.__code__.co_argcount
	if C==2:return lambda x:A(x,B)
	elif C==3:return lambda x,y:A(x,y,B)
	else:return lambda x,y,z:A(x,y,z,B)
def GK(A,B):return lambda x:A(x)==B
def YJ(h,g,f):return lambda x:h(g(f(x)))
def GW(A,B):return lambda x:A(B(x))
def HJ(A,a,b):return a if A else b
def GS(a,b):return frozenset((B,A)for A in b for B in a)
def GQ(a,b):return a,b
def GY(A,B,C):return tuple(range(A,B,C))
def HY(A,B):return B.union(frozenset({A}))
def YU(A):return max(enumerate(A))[1]
def HS(A):return next(iter(A))
def GE(A,B):return type(A)(A for A in A if B(A))
def R(x):return x-1 if isinstance(x,int)else(x[0]-1,x[1]-1)
def U(x):return x+1 if isinstance(x,int)else(x[0]+1,x[1]+1)
def YX(a,b):return a and b
def GL(A):return frozenset({A})
def HM(A,B):return min(A,key=B)
def HR(A,B):return B(max(A,key=B,default=0))
def HP(A):return type(A)(B for A in A for B in A)
def GX(a,b):return a>b
def HH(A,B):return tuple(A for B in range(B))
def J(a,b):return type(a)(A for A in a if A not in b)
def GR(a,b):return type(a)((*a,*b))
def GJ(a,b):return a==b
def HW(n):return n//2 if isinstance(n,int)else(n[0]//2,n[1]//2)
def HG(n):return-n if isinstance(n,int)else(-n[0],-n[1])
def L(a,b):
	if isinstance(a,int)and isinstance(b,int):return a*b
	elif isinstance(a,tuple)and isinstance(b,tuple):return a[0]*b[0],a[1]*b[1]
	elif isinstance(a,int)and isinstance(b,tuple):return a*b[0],a*b[1]
	return a[0]*b,a[1]*b
def GG(a,b):
	if isinstance(a,int)and isinstance(b,int):return a-b
	elif isinstance(a,tuple)and isinstance(b,tuple):return a[0]-b[0],a[1]-b[1]
	elif isinstance(a,int)and isinstance(b,tuple):return a-b[0],a-b[1]
	return a[0]-b,a[1]-b
def YK(a,b):
	if isinstance(a,int)and isinstance(b,int):return a+b
	elif isinstance(a,tuple)and isinstance(b,tuple):return a[0]+b[0],a[1]+b[1]
	elif isinstance(a,int)and isinstance(b,tuple):return a+b[0],a+b[1]
	return a[0]+b,a[1]+b
def W(x):return x
def p(I):I=tuple(map(tuple,I));P=H(I);A=HP(P);T=Q(I);D=X(A);F=GV(A);V=HX(A);a=HL(A);b=GY(7,1,-1);c=YK(D,V);d=U(c);e=HK(GG,d);f=YK(F,a);g=U(f);h=HK(GG,g);i=HK(GY,D);j=HZ(i,1);k=GW(j,e);l=HK(GY,F);m=HZ(l,1);n=GW(m,h);o=YR(GS,k,n);p=YR(GJ,W,YH);q=YR(GJ,W,HE);r=YR(GJ,W,HV);s=YR(YX,q,r);t=YR(YX,p,s);u=YR(GQ,W,W);v=YR(L,W,W);w=GW(R,v);K=GL((0,0));x=J(K,K);y=HZ(HJ,x);z=HZ(Y,T);A0=HZ(GP,I);A1=HK(GW,Z);A2=HK(YR,HY);A3=HK(A2,W);A4=HK(GW,GL);A5=YJ(A1,A3,A4);A6=HK(HZ,YK);A7=YJ(A5,A6,R);A8=HK(YR,y);M=HK(YR,YX);A9=HK(M,t);AA=HZ(GW,YY);AB=GW(A9,AA);AC=HZ(GW,z);AD=HK(HK,GX);AE=YJ(AC,AD,w);AF=HK(HZ,GJ);AG=YJ(AB,AF,u);AH=YR(M,AE,AG);AI=HK(GW,A0);AJ=GW(AI,A7);AK=YR(GW,AH,AJ);AL=HK(GW,GL);AM=HK(HZ,GQ);AN=GW(AL,AM);AO=YR(A8,AK,AN);AP=YR(GZ,AO,o);AQ=HU(A);AR=GQ(AQ,1);AS=HH(AR,1);AT=GZ(AP,b);N=GR(AS,AT);AU=HR(N,YU);AV=GK(YU,AU);AW=GE(N,AV);AX=HU(A);AY=GL(AX);AZ=HZ(E,AY);Aa=GW(HW,YU);Ab=YR(YK,HS,Aa);Ac=GW(GL,Ab);Ad=GW(AZ,Ac);O=HM(AW,Ad);B=HS(O);Ae=YU(O);Af=R(Ae);Ag=YK(B,Af);Ah=GL(Ag);Ai=HY(B,Ah);Aj=Z(Ai);Ak=GP(Aj,I);C=S(Ak);Al=YH(I);Am=H(Al);An=HP(Am);Ao=HE(I);Ap=H(Ao);Aq=HP(Ap);Ar=HV(I);As=H(Ar);At=HP(As);Au=YH(I);Av=G(Au,C);Aw=HS(Av);Ax=HG(Aw);Ay=YG(An,Ax);Az=YG(Ay,B);A_=HE(I);B0=G(A_,C);B1=HS(B0);B2=HG(B1);B3=YG(Aq,B2);B4=YG(B3,B);B5=HV(I);B6=G(B5,C);B7=HS(B6);B8=HG(B7);B9=YG(At,B8);BA=YG(B9,B);BB=GR(Az,B4);BC=GR(BB,BA);BD=HQ(I,BC);return[*map(list,BD)]