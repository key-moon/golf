Here’s a very short “golfed” Python solution.  It finds all columns of 5’s, picks the longest‐column →1 and shortest‐column →2, zeroing every other 5:

```
def p(val_g):
    val_a=[c.count(5)for c in zip(*val_g)]
    val_b,max;val_b=max(val_a);val_c=min(val_a)
    return[[(val_v==5)*((val_k==val_b)+(val_k==val_c)*2)
            for val_v,val_k in zip(val_r,val_a)]
           for val_r in val_g]
```

Explanation of the key steps:

1.  `val_a=[c.count(5)for c in zip(*val_g)]`  
    Compute for each column `c` how many 5’s it has.

2.  `val_b=max(val_a)` / `val_c=min(val_a)`  
    Identify the maximum‐length and minimum‐length columns.

3.  The double list‐comprehension rebuilds the grid:  
    -  `for val_r in val_g`  loops over each row.  
    -  `for val_v,val_k in zip(val_r,val_a)` loops over each cell value `val_v` and its column‐count `val_k`.  
    -  `(val_v==5)*((val_k==val_b)+(val_k==val_c)*2)`  
       is 0 unless `val_v==5`.  If a 5 and in the longest column, `(val_k==val_b)` is true →1.  
       If a 5 and in the shortest column, `(val_k==val_c)` is true →2.  
       All other 5’s become 0.