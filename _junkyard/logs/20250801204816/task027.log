Here’s a very short “concave‐corner‐fill” solver.  It repeatedly finds any 0‐cell that sits in a 90° concave corner of the 1s (or of cells we’ve already turned to 2) and paints it 2, until nothing more can be filled.

```python
def p(g):
    val_h,val_w=len(g),len(g[0])
    val_v=lambda r,c:0<=r<val_h and 0<=c<val_w and g[r][c]>0
    while 1:
        val_a=[(r,c)
            for r in range(val_h) for c in range(val_w)
            if g[r][c]==0 and (
               val_v(r-1,c) and val_v(r,c-1) or
               val_v(r-1,c) and val_v(r,c+1) or
               val_v(r+1,c) and val_v(r,c-1) or
               val_v(r+1,c) and val_v(r,c+1)
            )]
        if not val_a: break
        for r,c in val_a: g[r][c]=2
    return g
```

Explanation of the key test:
- A zero at (r,c) is in a concave corner if it has one filled neighbor vertically (up or down) and one filled neighbor horizontally (left or right).  
- We flood those “corner” zeros to 2, then repeat, which propagates the fill over the entire concave indentation.