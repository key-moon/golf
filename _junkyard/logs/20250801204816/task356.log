Here is a single‐function, “code‐golf”–style solution.  It simply records all the 8‐cells, then for each row (resp. column) that contains ≥2 of them it fills in the horizontal (resp. vertical) span between the leftmost and rightmost (resp. topmost and bottommost) original 8’s in that line:

```python
def p(val_g):
    # collect all original 8‐positions
    val_o=[(val_i,val_j)
           for val_i,val_r in enumerate(val_g)
           for val_j,val_v in enumerate(val_r)
           if val_v==8]
    # for each row with ≥2 originals, fill the min…max span
    for val_i in {val_i for val_i,_ in val_o}:
        val_L=[val_j for ii,val_j in val_o if ii==val_i]
        a,b=min(val_L),max(val_L)
        for val_j in range(a,b+1): val_g[val_i][val_j]=8
    # for each column with ≥2 originals, fill the min…max span
    for val_j in {val_j for _,val_j in val_o}:
        val_L=[val_i for val_i,jj in val_o if jj==val_j]
        a,b=min(val_L),max(val_L)
        for val_i in range(a,b+1): val_g[val_i][val_j]=8
    return val_g
```

Explanation of the key steps:

1. **val_o** gathers all the coordinates of the 8’s in the input.
2. We look at each **row** index `val_i` that appears in `val_o`.  If that row has ≥2 originals, we find the leftmost/rightmost columns `a,b` among them and set every cell in `val_g[val_i][a..b]` to 8.
3. We do the same for each **column** index `val_j` that appears in `val_o`: if that column has ≥2 originals, we fill every cell in `val_g[a..b][val_j]`.

This produces exactly the spans shown in all the examples.