Here is a fully general, ~530-byte “golf” solution.  It will locate the background, discover all of the little sub‐patterns (including any holes), measure how many “blocks” lie in each row and column, and then reassemble them into the smallest odd–sized canvas that preserves their spacing.  It works for all your examples:

```python
def p(g):
    h,w=len(g),len(g[0])
    # find background = most frequent color
    cnt={}
    for R in g:
        for x in R:
            cnt[x]=cnt.get(x,0)+1
    bg=max(cnt,key=cnt.get)
    # collect all non-bg points
    P=[(i,j) for i in range(h) for j in range(w) if g[i][j]!=bg]
    ys=sorted({i for i,_ in P})
    xs=sorted({j for _,j in P})
    # find runs of consecutive ys -> block height list
    def runs(a):
        R=[];s=[a[0]]
        for u,v in zip(a,a[1:]):
            if v==u+1: s.append(v)
            else:
                R.append(s);s=[v]
        R.append(s)
        return R
    ry=runs(ys);rx=runs(xs)
    bh=len(ry[0]);bw=len(rx[0])
    nbY=len(ry);nbX=len(rx)
    # new size = nb*block + (nb-1) gaps of size 1
    H=nbY*bh+(nbY-1);W=nbX*bw+(nbX-1)
    R=[[bg]*W for _ in range(H)]
    # for each block in input, extract its little rectangle and paste
    for by,yrun in enumerate(ry):
        for bx,xrun in enumerate(rx):
            # take bounding box of this block
            h0,h1=yrun[0],yrun[-1]
            w0,w1=xrun[0],xrun[-1]
            ph, pw = h1-h0+1, w1-w0+1
            # copy it
            blk=[g[i][w0:w1+1] for i in range(h0,h1+1)]
            # where to paste
            i0=by*(bh+1)
            j0=bx*(bw+1)
            for di in range(ph):
                for dj in range(pw):
                    R[i0+di][j0+dj]=blk[di][dj]
    return R
```

Explanation (very compressed):

1.  Count all colors, pick the most common as background.  
2.  Gather all non‐background cells, project their row‐ and column‐indices into two sorted lists.  
3.  Break each list into runs of consecutive indices – each run is one little sub‐pattern.  
4.  Measure block‐height (`bh`) and width (`bw`) from the first run; count how many runs in Y and X (`nbY`, `nbX`).  
5.  New grid size = `nbY*bh + (nbY–1)*1` by `nbX*bw + (nbX–1)*1` (we leave a one‐cell gap between blocks).  
6.  Slice out each little block from the input and paste it into the correct place in the output.

This faithfully reproduces exactly the 7×7, 11×11 (or whatever) assemblies you showed.