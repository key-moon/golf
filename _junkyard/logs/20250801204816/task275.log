Here’s a short golfed solution that matches all the samples.  It takes the top‐left k×k corner (k=min(height,width)) of the input, and for every nonzero cell (i,j) in that corner it stamps a “+” of arm‐length k//2 in the k²×k² output, using the same value v=g[i][j]:

```python
def p(g):
    h,w=len(g),len(g[0])
    k=min(h,w);n=k*k
    o=[[0]*n for _ in[0]*n]
    for i in range(k):
      for j in range(k):
        v=g[i][j]
        if v:
          x=i*k+k//2; y=j*k+k//2
          for d in range(n):
            if d//k==i or d%k==j:
              o[d//k*k+k//2][d%k*k+k//2]=v
    return o
```

Explanation of the key steps:

– We choose k=min(H,W) and build an output of size (k²)×(k²).  
– We only scan the top‐left k×k corner of g.  
– For each nonzero at (i,j) we compute its “center” in the big grid:  
   cx=i*k + k//2, cy=j*k + k//2  
– We then draw a “+” by writing v to all positions in row cx and column cy.