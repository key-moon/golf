Here is a fully‐golfed one‐liner (no imports, only local `val_…` names, single `def p(val_g):` signature).  It first crops out the minimal nonzero‐box, reads its outer‐color `val_b` and inner‐color `val_e` (from its center), then builds a new same‐sized box with those two swapped (i.e. border→`val_e`, interior→`val_b`):

```python
def p(val_g):val_r=[val_i for val_i,val_row in enumerate(val_g)if any(val_row)];val_c=[val_j for val_j,val_col in enumerate(zip(*val_g))if any(val_col)];val_a=[val_row[val_c[0]:val_c[-1]+1]for val_row in val_g[val_r[0]:val_r[-1]+1]];val_h,val_w=len(val_a),len(val_a[0]);val_b=val_a[0][0];val_e=val_a[val_h//2][val_w//2];return[[val_e if val_i*val_j*(val_h-1-val_i)*(val_w-1-val_j)==0 else val_b for val_j in range(val_w)]for val_i in range(val_h)]
```

Explanation of the key steps:

1.  Find the minimal row/column ranges (`val_r`, `val_c`) that contain any nonzero.
2.  Crop out `val_a` = `val_g[val_r[0]:val_r[-1]+1][…][val_c[0]:val_c[-1]+1]`.
3.  `val_b` ← outer‐color = top‐left of `val_a`;  `val_e` ← inner‐color = center of `val_a`.
4.  Build a new box of the same height/width, using `val_e` on the border (where `i*j*(h−1−i)*(w−1−j)==0`) and `val_b` inside.