Here’s a fully self‐contained “hole‐filling” solution.  It walks all the zero‐pixels on the border, floods them (marks them −1), then anything left at 0 must be a hole → paint it 2, and finally restore the −1’s back to 0.  Variable names all start with `val_` and I squeezed it into one statement‐block—no extra imports, no extraneous line‐breaks:

```python
def p(g):
    val_h,val_w=len(g),len(g[0])
    val_s=[(i,j)for i in(0,val_h-1)for j in range(val_w)]+[(i,j)for i in range(val_h)for j in(0,val_w-1)]
    for val_i,val_j in val_s:
        if g[val_i][val_j]==0:g[val_i][val_j]=-1
    while val_s:
        val_i,val_j=val_s.pop()
        for val_a,val_b in((val_i-1,val_j),(val_i+1,val_j),(val_i,val_j-1),(val_i,val_j+1)):
            if 0<=val_a<val_h and 0<=val_b<val_w and g[val_a][val_b]==0:
                g[val_a][val_b]=-1;val_s.append((val_a,val_b))
    for val_i in range(val_h):
        for val_j in range(val_w):
            if g[val_i][val_j]==0:   g[val_i][val_j]=2
            elif g[val_i][val_j]<0:  g[val_i][val_j]=0
    return g
```

Explanation of the key steps:

 1.  **Collect all border zeros** in `val_s` and immediately mark them `-1` to mean “this zero is *not* a hole.”  
 2.  **Flood–fill** from those in `val_s` over all 4‐neighbors, marking any reachable zero as `-1` as well.  
 3.  After no more floods are possible, **what’s still a 0** is a genuine enclosed hole → paint it `2`.  
 4.  Finally flip all the temporary `-1`s back to `0` and return the modified grid.