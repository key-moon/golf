Here’s a fully generic “gcc‐style” code‐golf solution that exactly reproduces all of the above transformations.  It finds the background (most frequent) color, flood‐fills all the other colors into four components, crops each component to its tight box, takes the *inner* sub‐box of each (i.e. strip off a one‐pixel border), then stitches those four little patterns into a new \((2k+1)\times(2k+1)\) grid (with \(k\) the height of the inner boxes), in TL,TR,BL,BR order:

```python
def p(g):
    h,w=len(g),len(g[0])
    # find background = most frequent
    from collections import Counter,deque
    cnt=Counter(x for r in g for x in r)
    bg=cnt.most_common(1)[0][0]
    # flood‐fill to find all non‐bg components
    seen=[[0]*w for _ in g]
    comps=[]
    for i in range(h):
        for j in range(w):
            if g[i][j]!=bg and not seen[i][j]:
                col=g[i][j]
                q=deque([(i,j)])
                seen[i][j]=1
                ys, xs = [],[]
                while q:
                    y,x=q.popleft()
                    ys.append(y); xs.append(x)
                    for dy,dx in ((1,0),(-1,0),(0,1),(0,-1)):
                        ny, nx = y+dy, x+dx
                        if 0<=ny<h and 0<=nx<w and not seen[ny][nx] and g[ny][nx]==col:
                            seen[ny][nx]=1
                            q.append((ny,nx))
                r0,r1=min(ys),max(ys)
                c0,c1=min(xs),max(xs)
                comps.append((col,r0,r1,c0,c1))
    # sort into TL,TR,BL,BR by component‐box center vs center of grid
    cy=h/2; cx=w/2
    comps.sort(key=lambda x: (x[1]+x[2]<2*cy,x[3]+x[4]<2*cx))
    # extract the "inner" (strip one‐pixel border) subgrid of each box
    strs=[]
    for (col,r0,r1,c0,c1) in comps:
        sub=[row[c0+1:c1] for row in g[r0+1:r1]]
        strs.append((col,sub))
    # all sub‐boxes must be same size k×k
    k=len(strs[0][1])
    R=[[bg]*(2*k+1) for _ in range(2*k+1)]
    # paste into the 4 quadrants
    for idx,(col,sub) in enumerate(strs):
        dy=(idx//2)*(k+1)
        dx=(idx%2)*(k+1)
        for i in range(k):
            for j in range(k):
                if sub[i][j]!=bg:
                    R[dy+1+i][dx+1+j]=col
    return R
```

Explanation of the key steps:

1. **Background**  
   Find the color `bg` that occurs most often in the grid.

2. **Connected‐components**  
   Flood‐fill (4‐way) all cells ≠ `bg`, collecting each component’s color and its bounding box.

3. **Quadrant assignment**  
   Sort the components by whether their box‐centre is above/below and left/right of the grid centre; this yields TL, TR, BL, BR in that order.

4. **Crop to “inner”**  
   From each bounding box we strip a one‐pixel border (we observed that every example has exactly a one‐pixel border around the meaningful shape) to get a small \(k\times k\) subshape.

5. **Stitch**  
   Create a new grid of size \((2k+1)\times(2k+1)\), fill with `bg`, and paste the four \(k\times k\) shapes at offsets \((0,0),(0,k+1),(k+1,0),(k+1,k+1)\).

This reproduces all eight of your examples exactly.