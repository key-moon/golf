Here’s a single‐function, code‐golfed solution (using only one‐letter locals and no imports) that implements exactly the “L–shaped” extension rule seen in your examples.  You can drop in your 2D list of lists `g` and get the transformed grid back:

```python
def p(g):
 d={}
 for i,r in enumerate(g):
  for j,v in enumerate(r):
   if v:d.setdefault(v,[]).append((i,j))
 a=min(d,key=lambda v:(min(i for i,_ in d[v]),min(j for _,j in d[v])))
 ar,minc=min(i for i,_ in d[a]),min(j for _,j in d[a])
 b=next(v for v in d if v!=a and min(i for i,_ in d[v])==ar)
 c=next(v for v in d if v!=a and min(j for _,j in d[v])==minc)
 dr=min(i for i,_ in d[c])-ar; dc=min(j for _,j in d[b])-minc
 M,N=len(g),len(g[0])
 mb=(N-1-max(j for _,j in d[b]))//dc
 for k in range(1,mb+1):
  for i,j in d[b]:g[i][j+dc*k]=b
 mc=(M-1-max(i for i,_ in d[c]))//dr
 for k in range(1,mc+1):
  for i,j in d[c]:g[i+dr*k][j]=c
 return g
```

Explanation of the steps:

1.  Collect for each non‐zero color `v` the list of its coordinates in `d[v]`.
2.  Identify the “anchor” color `a` as the one whose top‐left corner (minimum row, then minimum column) is lexicographically smallest.
3.  On the anchor’s row find the other shape `b`; on its column find the other shape `c`.
4.  Compute the offsets `dc` (horizontal step) and `dr` (vertical step) between `b` and `a`, and between `c` and `a`.
5.  Tile shape `b` to the right as far as it fits, and tile shape `c` downward as far as it fits.
6.  Return the in–place modified grid.

This exactly reproduces all of your training examples.