Here’s a single‐function solution that (1) scans for any “prototype” centre cell v that already has more than one nonzero neighbour, records the relative offsets of those neighbours and their colour, then (2) for every cell of colour v in the grid it “replays” that pattern by writing the neighbour‐colours at the same offsets.  All variable names except the underscore are prefixed by `val_` as requested.

```python
def p(g):
    val_m,val_n=len(g),len(g[0])
    val_D,val_A={},{}
    # 1) find prototypes: any v with >1 nonzero neighbour
    for val_i in range(val_m):
        for val_j in range(val_n):
            v=g[val_i][val_j]
            if v and v not in val_D:
                val_o=[]
                for val_di,val_dj in((1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)):
                    x,y=val_i+val_di,val_j+val_dj
                    if 0<=x<val_m and 0<=y<val_n and g[x][y]:
                        val_o.append((val_di,val_dj))
                if len(val_o)>1:
                    val_D[v]=val_o
                    # take the first neighbour’s colour as the “arm” colour
                    val_A[v]=g[val_i+val_o[0][0]][val_j+val_o[0][1]]
    # 2) replay each prototype at every centre cell of that colour
    for val_i in range(val_m):
        for val_j in range(val_n):
            v=g[val_i][val_j]
            if v in val_D:
                for val_di,val_dj in val_D[v]:
                    g[val_i+val_di][val_j+val_dj]=val_A[v]
    return g
```

Explanation of the key steps:

1. **Prototype discovery**  
   We walk every nonzero cell `(i,j)` once.  
   – We gather all eight‐way neighbour offsets `(di,dj)` for which `g[i+di][j+dj]` is nonzero.  
   – If a cell `v` has more than one such neighbour, we declare it a *prototype centre* of colour `v`, record its neighbour‐offset list `D[v]`, and record the common neighbour-colour `A[v]` (all prototypes in our ARC tasks use a uniform arm-colour).

2. **Pattern replay**  
   We then scan the grid again.  Whenever we see a cell of colour `v` for which we recorded a prototype, we write `A[v]` into all of its neighbour positions given by `D[v]`.  

This exactly fills in every “half­-drawn” motif in the input, whether it is a plus, an X, a horizontal bar, a vertical bar, etc., matching exactly the examples above.