Here is a very terse “code‐golf”‐style solution.  It finds the 3’s (which mark the four corners of a square), computes that bounding box, gathers all 2‐cells within it, and for each performs a 90° clockwise move inside the same box.  All variables (apart from implicit `_` etc.) are prefixed with `val_` as requested:

```python
def p(val_g):
    val_h=[val_R[:]for val_R in val_g]
    val_z=[(val_I,val_J)
           for val_I in range(len(val_g))
           for val_J in range(len(val_g[0]))
           if val_g[val_I][val_J]==3]
    val_r0=min(val_I for val_I,val_J in val_z)
    val_r1=max(val_I for val_I,val_J in val_z)
    val_c0=min(val_J for val_I,val_J in val_z)
    val_c1=max(val_J for val_I,val_J in val_z)
    val_t=[(val_I,val_J,
            val_r0+val_J-val_c0,
            val_c1+val_r0-val_I)
           for val_I in range(val_r0,val_r1+1)
           for val_J in range(val_c0,val_c1+1)
           if val_g[val_I][val_J]==2]
    [ val_h[val_I].__setitem__(val_J,0)
      or
      val_h[val_K].__setitem__(val_L,2)
      for val_I,val_J,val_K,val_L in val_t ]
    return val_h
```

Explanation of the key steps:

1.  Copy the input grid `val_g` into `val_h`.  
2.  Locate all the 3’s; their min/max row and column give the square bounding‐box.  
3.  Walk that box, collect every 2‐cell `(I,J)`, and compute its clockwise‐rotated target `(K,L)` inside the box.  
4.  In one list‐comprehension side‐effect, clear each old 2 and set each new one.  
5.  Return the modified copy.