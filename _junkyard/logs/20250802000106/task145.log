Here’s a single‐pass flood‐fill solution.  It finds every “corner” of two orthogonal runs of 2’s (an L‐joint), then flood‐fills the concave side of that L with 1 and the convex side with 8.  All variables except “_” are prefixed with `val_` and everything is put into one function `p(g)`.  

```python
def p(val_g):
    val_h,val_w=len(val_g),len(val_g[0]);val_D=[(1,0),(-1,0),(0,1),(0,-1)]
    for val_i in range(val_h):
        for val_j in range(val_w):
            if val_g[val_i][val_j]==2:
                val_b=[d for d in val_D
                       if 0<=val_i+d[0]<val_h and 0<=val_j+d[1]<val_w
                       and val_g[val_i+d[0]][val_j+d[1]]==2]
                for val_x in range(len(val_b)):
                    for val_y in range(val_x+1,len(val_b)):
                        val_u,val_v=val_b[val_x],val_b[val_y]
                        if val_u[0]*val_v[0]+val_u[1]*val_v[1]==0:
                            for val_s,val_c in [
                                ((-val_u[0]-val_v[0],-val_u[1]-val_v[1]),1),
                                (( val_u[0]+val_v[0], val_u[1]+val_v[1]),8)
                            ]:
                                val_X,val_Y=val_i+val_s[0],val_j+val_s[1]
                                if 0<=val_X<val_h and 0<=val_Y<val_w and val_g[val_X][val_Y]==0:
                                    val_S=[(val_X,val_Y)];val_g[val_X][val_Y]=val_c
                                    while val_S:
                                        val_a,val_b0=val_S.pop()
                                        for val_dx,val_dy in val_D:
                                            val_A,val_B=val_a+val_dx,val_b0+val_dy
                                            if 0<=val_A<val_h and 0<=val_B<val_w and val_g[val_A][val_B]==0:
                                                val_g[val_A][val_B]=val_c
                                                val_S.append((val_A,val_B))
    return val_g
```

Explanation of the core steps:

 1. Scan every cell `(i,j)` looking for `2`.
 2. Gather the orthogonal neighbors of `(i,j)` that are also `2` into `val_b`.
 3. For every pair of distinct neighbors in `val_b` that are not colinear (i.e. form an L), compute two offset directions:
    - `(-u - v)`: points into the concave corner of the L → fill with `1`.
    - `(u + v)`: points into the convex corner of the L → fill with `8`.
 4. From each such start cell, perform a standard flood‐fill (stack + 4‐way) of all connected zeros, coloring them `1` or `8` as appropriate.
 5. Return the modified grid.