import copy
E=enumerate
A=range
S=sorted
N=None
G,R,B=3,2,0
d=copy.deepcopy
def ib(g,r,c):return 0<=r<len(g)and 0<=c<len(g[0])
def n(r,c):return[(r+1,c),(r-1,c),(r,c+1),(r,c-1)]
def ad(a,b):return a[0]+b[0],a[1]+b[1]
def sb(a,b):return a[0]-b[0],a[1]-b[1]
def nm(d):return tuple(map(lambda x:(x>0)-(x<0),d))
def rl(d):return-d[1],d[0]
def rr(d):return d[1],-d[0]
def m(a,b):return abs(a[0]-b[0])+abs(a[1]-b[1])
def fp(g,v):return[(A,C)for(A,B)in E(g)for(C,D)in E(B)if D==v]
def c4c(ps):
 A,E=set(ps),[]
 while A:
  F=A.pop();D=[F];G=[F]
  while D:
   O,I=D.pop()
   for(B,C)in n(O,I):
    if(B,C)in A:A.remove((B,C));D.append((B,C));G.append((B,C))
  E.append(G)
 return E
def cg(gs,p):return min(m(p,A)for A in gs)if gs else 1e9
def l(v):return v in(B,G)
def rs(g,s,f,rs):
 Q,S=len(g),len(g[0]);C=d(g);T=set();J=0;A=s;F=cg(rs,A);K=F;L=0
 while J<Q*S*10:
  J+=1;D=ad(A,f)
  if ib(g,*D)and C[D[0]][D[1]]==R:break
  if not ib(g,*D)or not l(C[D[0]][D[1]]):
   L+=1;h,U=rl(f),rr(f);O=[]
   for N in(h,U):
    E=ad(A,N)
    if ib(g,*E)and l(C[E[0]][E[1]]):O.append((cg(rs,E),N,E))
   if O:O.sort(key=lambda x:(x[0],0 if x[1]==h else 1));e,f,A=O[0]
   else:
    s=-f[0],-f[1];I=ad(A,s)
    if ib(g,*I)and l(C[I[0]][I[1]]):f,A=s,I
  else:A=D
  if C[A[0]][A[1]]==B:C[A[0]][A[1]]=G
  V=A,f;T.add(V);n=cg(rs,A);F=min(F,n);K=n
 return C,J,F,K,L
def ds(g):B,O=fp(g,R),fp(g,G);A=min(c4c(O),key=lambda x:(len(x),cg(B,(round(sum(A for(A,B)in x)/len(x)),round(sum(A for(B,A)in x)/len(x))))));I=set(A);C=next((((A,B),(C,D))for(A,B)in A for(C,D)in n(A,B)if(C,D)in I),N);C=C or max(((B,C)for B in A for C in A),key=lambda x:m(*x));E,F=C;D=nm(sb(F,E));J=[rs(g,F,D,B),rs(g,E,(-D[0],-D[1]),B)];return S(J,key=lambda x:(x[3],x[4],x[2],x[1]))[0][0]
def br(g):
 Q,T=fp(g,R),fp(g,G);e=lambda ps:S(ps)[0][1]==S(ps)[1][1]and abs(S(ps)[0][0]-S(ps)[1][0])==1;(I,F),(J,U)=S(T);(K,O),(L,U)=S(Q)
 if{I,J}!={K,L}:return
 h,s=S([F,O]);E=N
 for C in A(min(I,K)+1):
  if all(g[C][A]in(B,G,R)for A in A(h,s+1)):E=C;break
 if E in(N,0):return
 D=d(g);V=max(J,L)
 for C in A(E,V+1):
  if D[C][F]==B:D[C][F]=G
  if D[C][O]==B:D[C][O]=G
 for n in A(h,s+1):
  if D[E][n]==B:D[E][n]=G
 return D
def p(g):return br(g)or ds(g)