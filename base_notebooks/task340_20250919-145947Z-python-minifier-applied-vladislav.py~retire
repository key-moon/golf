def p(g):
	X=False;R=True;B=tuple(tuple(A)for A in g);A,C=len(B),len(B[0])
	def Y(G):from collections import Counter as A;B=A(B for A in G for B in A);return max(B.items(),key=lambda kv:kv[1])[0]
	I=Y(B)
	def J(vals):
		from collections import Counter as B;A=B(A for A in vals if A!=I)
		if not A:return I
		return max(A.items(),key=lambda kv:kv[1])[0]
	S=J(B[0]);T=J(B[-1]);U=J([B[A][0]for A in range(A)]);V=J([B[A][-1]for A in range(A)]);K=[[X]*C for A in range(A)];P=[]
	def Z(i,j):
		for(E,F)in((1,0),(-1,0),(0,1),(0,-1)):
			B,D=i+E,j+F
			if 0<=B<A and 0<=D<C:yield(B,D)
	for D in range(A):
		for E in range(C):
			if K[D][E]:continue
			K[D][E]=R;F=B[D][E]
			if F==I:continue
			Q=[(D,E)];G=[];W=X
			while Q:
				L,M=Q.pop();G.append((L,M))
				if L==0 or L==A-1 or M==0 or M==C-1:W=R
				for(N,O)in Z(L,M):
					if not K[N][O]and B[N][O]==F:K[N][O]=R;Q.append((N,O))
			if not W:P.append((F,G))
	H=[list(A)for A in B]
	for(F,G)in P:
		for(D,E)in G:
			if F==S and A>=2:a,b=1,max(1,min(C-2,E));H[a][b]=S
			if F==T and A>=2:c,d=A-2,max(1,min(C-2,E));H[c][d]=T
			if F==U and C>=2:e,f=max(1,min(A-2,D)),1;H[e][f]=U
			if F==V and C>=2:h,i=max(1,min(A-2,D)),C-2;H[h][i]=V
	for(j,G)in P:
		for(D,E)in G:H[D][E]=I
	return[list(A)for A in H]