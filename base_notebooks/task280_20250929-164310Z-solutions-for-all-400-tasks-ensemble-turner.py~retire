def p(I,t=range):
 def c(p):A={};[A.__setitem__(B,A.get(B,0)+1)for C in p for B in C];return max(A,key=A.get)
 O=c(I);H,J=len(I),len(I[0]);L=[[0]*J for A in t(H)];P=[]
 for A in t(H):
  for B in t(J):
   if L[A][B]or I[A][B]==O:continue
   r=[(A,B)];L[A][B]=1;X=[]
   while r:D,E=r.pop();d=I[D][E];X.append((d,(D,E)));[r.append((A,B))or L[A].__setitem__(B,1)for(A,B)in[(D-1,E),(D+1,E),(D,E-1),(D,E+1)]if 0<=A<H and 0<=B<J and not L[A][B]and I[A][B]!=O]
   P.append(X)
 K=lambda s:list(s)if not s or not(isinstance(next(iter(s)),tuple)and len(next(iter(s)))==2and isinstance(next(iter(s))[1],tuple))else[A for(B,A)in s]
 def F(s):A=K(s);B,C=[A for(A,B)in A],[A for(B,A)in A];return min(B),max(B),min(C),max(C)
 R=lambda s:0 if not s else F(s)[1]-F(s)[0]+1;S=lambda s:0 if not s else F(s)[3]-F(s)[2]+1;T=lambda s:F(s)[0];Y=lambda s:F(s)[1];A=lambda s:F(s)[2];Z=lambda s:F(s)[3];e=lambda s:S(K(s))==1and R(K(s))==len(K(s))if K(s)else 0
 def f(a,b):A,B,C,D=*a,*b;E,F,G,H=min(A,C),max(A,C)+1,min(B,D),max(B,D)+1;return{(A,B)for B in t(G,H)}if A==C else{(A,B)for A in t(E,F)}if B==D else{(A,B)for(A,B)in zip(t(E,F),t(G,H))}if C-A==D-B else{(A,B)for(A,B)in zip(t(E,F),t(H-1,G-1,-1))}if C-A==B-D else set()
 d=lambda e,direction:f(e,(e[0]+42*direction[0],e[1]+42*direction[1]));V=[]
 for G in P:
  C={B for(A,B)in G if A==2}
  if not C:continue
  N,i,j,k=Y(C)==Y(G),Z(C)==Z(G),T(C)==T(G),A(C)==A(G);l,m=(1 if N else 0)+(-1 if j else 0),(1 if i else 0)+(-1 if k else 0);D,E=T(C)+R(C)//2,A(C)+S(C)//2;L=d((D,E),(l,m));V.append(L)
 n={B for A in V for B in A};N=[list(A)for A in I]
 for(A,B)in n:
  if 0<=A<H and 0<=B<J:N[A][B]=2
 W=set()
 for(G,L)in zip(P,V):
  s=e(L);a=min(R(G),S(G))
  for b in t(-(a-1),a):
   if s:W.update({(A,B+b)for(A,B)in L})
   else:W.update({(A+b,B)for(A,B)in L})
 for(A,B)in W:
  if 0<=A<H and 0<=B<J and N[A][B]==O:N[A][B]=3
 return N