def p(I,t=enumerate,p=range):
 from collections import Counter as M;a,b=len(I),len(I[0]);c=M(B for n in I for B in n);R=max(c,key=c.get);K=[(n,B)for n in p(a)for B in p(b)if I[n][B]!=R]
 if not K:return I
 B=min(n for(n,B)in K);G=max(n for(n,B)in K);C=min(n for(B,n)in K);H=max(n for(B,n)in K);L=M(I[n][B]for n in p(B,G+1)for B in p(C,H+1));R={n for n in L if n!=R};D=set()
 for E in p(B,G+1):D.add(I[E][C]);D.add(I[E][H])
 for F in p(C,H+1):D.add(I[B][F]);D.add(I[G][F])
 D.discard(R);n=R-D
 if n:n=max(n,key=lambda c:(L[c],-c))
 else:n=min(R,key=lambda c:(L[c],c))
 if D:e=max(D,key=lambda c:(L[c],-c))
 else:f=[B for B in R if B!=n];e=max(f,key=lambda c:(L[c],-c))if f else n
 N=[sum(1for C in p(C,H+1)if I[B][C]==n)for B in p(B,G+1)];O=[sum(1for B in p(B,G+1)if I[B][C]==n)for C in p(C,H+1)];T=[n for n in N if n];g=[n for n in O if n];h=[];D=[]
 if T:
  P=M(n for n in N if n);U=max(P.items(),key=lambda kv:(kv[1],-kv[0]))[0];V=min(T);l=max(T)
  if V>2and l-V==1:U=V
  h=[n for(n,B)in t(N)if B==U];D=[n for(n,B)in t(N)if B>U]
 j=[];k=[]
 if g:
  P=M(n for n in O if n);W=max(P.items(),key=lambda kv:(kv[1],-kv[0]))[0];X=min(g)
  if X>2and P[X]>1:W=X
  j=[n for(n,B)in t(O)if B==W];k=[n for(n,B)in t(O)if B>W]
 J=[list(n)for n in I]
 for E in p(B,G+1):
  for F in p(C,H+1):J[E][F]=e
 for l in h:
  Q=B+l
  for Z in j:J[Q][C+Z]=n
 for l in D:
  Q=B+l
  for F in p(0,C):J[Q][F]=n
  for F in p(H+1,b):J[Q][F]=n
 for Z in k:
  l=C+Z
  for E in p(0,B):J[E][l]=n
  for E in p(G+1,a):J[E][l]=n
 return J