M=max
d=min
R=range
def p(g):
 from collections import Counter as i,deque;o=i(l for h in g for l in h).most_common(1)[0][0];P,Q=len(g),len(g[0]);l={}
 for n in R(P):
  for I in R(Q):
   h=g[n][I]
   if h!=o:l.setdefault(h,set()).add((n,I))
 def O(T):
  l=set();t=[]
  for n in T:
   if n in l:continue
   D=deque([n]);l.add(n);F={n}
   while D:
    o,n=D.popleft()
    for(I,S)in((1,0),(-1,0),(0,1),(0,-1)):
     h=o+I,n+S
     if h in T and h not in l:l.add(h);D.append(h);F.add(h)
   t.append(F)
  return t
 def D(T):h=[h for(h,l)in T];l=[h for(l,h)in T];return d(h),d(l),M(h),M(l)
 def S(T):h,l,n,n=D(T);return{(n-h,D-l)for(n,D)in T}
 def U(T):h,l,n,l=D(T);t=h+n;return{(t-h,l)for(h,l)in T}
 def h(T):h,l,h,n=D(T);t=l+n;return{(h,t-l)for(h,l)in T}
 def n(T):h,l,n,n=D(T);return{(D-l+h,n-h+l)for(n,D)in T}
 def V(T):return h(n(h(T)))
 def T(T):l=[h(T),n(T),V(T),U(T)];return d(l,key=lambda U:sorted(S(U)))
 def I(D,t):return d(abs(h-n)+abs(l-D)for(h,l)in D for(n,D)in t)
 def X(L):h=O(l[L]);D=M((M(h for(l,h)in h)-d(h for(l,h)in h)+1for h in h),default=0);n=[I(h[l],h[n])for l in R(len(h))for n in R(l+1,len(h))];t=d(n)-1if n else-2;return-(2*D+t)
 t=sorted(l,key=X);S={h:S(T(l[h]))for h in t};E=len(t);I=E if any(len(l[h])==1for h in t)else E+1;F=2*I-1;n=[[o]*F for h in R(F)];t=[(l,(n+h,D+h))for(h,l)in enumerate(t)for(n,D)in S[l]]
 def D(D):return[list(h)for h in zip(*D[::-1])]
 def o(D):
  for(n,(h,l))in t:
   if 0<=h<F and 0<=l<F:D[h][l]=n
  return D
 for a in R(3):n=o(n);n=D(n)
 return o(n)
